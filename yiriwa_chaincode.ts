import { Context, Contract, Info, Returns, Transaction } from 'fabric-contract-api';
import * as crypto from 'crypto';

/**
 * Yiriwa Offline Protocol (YOP) v2.0 - Chaincode (Smart Contract)
 * * This contract serves as the "Settlement Layer". It validates offline transactions
 * uploaded by merchants and updates the global ledger state.
 */

// Define the Wallet State Structure
class UserWallet {
    public docType: string;
    public cardId: string;
    public balance: number;
    public lastNonce: number; // Anti-Replay Counter
    public publicKey: string; // PEM format or hex encoded

    constructor(cardId: string, publicKey: string, initialBalance: number) {
        this.docType = 'wallet';
        this.cardId = cardId;
        this.publicKey = publicKey;
        this.balance = initialBalance;
        this.lastNonce = 0;
    }
}

@Info({title: 'YiriwaOfflineContract', description: 'Settlement for Offline NFC Transactions'})
export class YiriwaContract extends Contract {

    /**
     * Initialize the Ledger with a demo user.
     * In production, this would be handled by a specific registration MSP.
     */
    @Transaction()
    public async InitLedger(ctx: Context): Promise<void> {
        const demoCardId = '12345678';
        // Demo Public Key (Example SECP256R1 Public Key)
        const demoPubKey = '-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE...\n-----END PUBLIC KEY-----';
        
        const wallet = new UserWallet(demoCardId, demoPubKey, 10000);
        
        await ctx.stub.putState(demoCardId, Buffer.from(JSON.stringify(wallet)));
        console.info(`Wallet ${demoCardId} initialized`);
    }

    /**
     * Process Batch Upload (The "Sync" Step)
     * * This function is called by the Merchant's backend. It submits the 
     * proof generated by the offline card.
     * * @param cardId The ID of the user card
     * @param merchantId The ID of the merchant claiming funds
     * @param amount The amount spent
     * @param nonce The counter used for this specific transaction
     * @param signatureHex The ECDSA signature provided by the card
     */
    @Transaction()
    public async ProcessOfflineTransaction(
        ctx: Context, 
        cardId: string, 
        merchantId: string, 
        amount: number, 
        nonce: number, 
        signatureHex: string
    ): Promise<string> {
        
        // 1. Fetch User Wallet from State
        const walletData = await ctx.stub.getState(cardId);
        if (!walletData || walletData.length === 0) {
            throw new Error(`Wallet ${cardId} does not exist`);
        }
        const wallet: UserWallet = JSON.parse(walletData.toString());

        // 2. Anti-Replay Check (Nonce)
        // The card increments nonce for every tx. Ledger must see strictly higher nonce.
        if (nonce <= wallet.lastNonce) {
            throw new Error(`Replay Detected: Nonce ${nonce} is <= Last Known Nonce ${wallet.lastNonce}`);
        }

        // 3. Cryptographic Verification
        // Reconstruct the message that was signed on the card:
        // Message = Amount (4 bytes) + Nonce (4 bytes) + MerchantID (8 bytes) + TerminalNonce (4)
        // Note: For simplicity in TS, we assume the inputs are concatenated strings or buffers. 
        // In a real impl, strict byte-level reconstruction matching Java Card is required.
        const isValid = this.verifySignature(wallet.publicKey, signatureHex, amount, nonce, merchantId);
        
        if (!isValid) {
            throw new Error(`Invalid Signature. Auth Failed.`);
        }

        // 4. Update Balances (Settlement)
        // In a real system, we would also fetch and update the Merchant's wallet.
        if (wallet.balance < amount) {
            throw new Error(`Insufficient funds on Ledger. ShadowBalance might be out of sync.`);
        }

        wallet.balance -= amount;
        wallet.lastNonce = nonce; // Advance the counter

        // 5. Commit State
        await ctx.stub.putState(cardId, Buffer.from(JSON.stringify(wallet)));

        // Emit Event for external listeners (e.g. notifications)
        const event = { cardId, merchantId, amount, nonce };
        ctx.stub.setEvent('OfflineTransactionSettled', Buffer.from(JSON.stringify(event)));

        return `Success. New Balance: ${wallet.balance}`;
    }

    /**
     * Helper: Verify ECDSA Signature (Secp256r1)
     */
    private verifySignature(publicKeyPem: string, signatureHex: string, amount: number, nonce: number, merchantId: string): boolean {
        try {
            // Recreate the data payload signed by the Java Card
            // Format must match Applet: Amount || Nonce || MerchantID
            // For this TS example, we treat them as a combined string buffer or similar.
            // In production: Use Buffer.alloc() to match byte alignments exactly.
            const payload = `${amount}:${nonce}:${merchantId}`; 
            
            const verify = crypto.createVerify('SHA256');
            verify.update(payload);
            verify.end();
            
            return verify.verify(publicKeyPem, signatureHex, 'hex');
        } catch (error) {
            console.error('Crypto Verification Error', error);
            return false;
        }
    }

    /**
     * Query Balance
     */
    @Transaction(false)
    @Returns('string')
    public async GetWallet(ctx: Context, cardId: string): Promise<string> {
        const walletData = await ctx.stub.getState(cardId);
        if (!walletData || walletData.length === 0) {
            throw new Error(`${cardId} does not exist`);
        }
        return walletData.toString();
    }
}
